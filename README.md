## Jonathan H. R. Lopes

Software developer with 14 years of software development experience and 8 years of professional experience (2 years freelance and 6 years full-time).

### 🔭 Experience

#### Professional

I'm currently working at [Audibene](https://www.audibene.de/)/[Hear.com](https://hear.com) with:

* *☕* Java
* *🐍* Python
* *📝* JavaScript / TypeScript

Using the following technologies:

* 🌱 Spring Boot
* 📗 PostgreSQL
* ✉️ Pulsar
* 💾 Redis
* 👀 New Relic and Open Telemetry
* ⚛️ ReactJS
* ⛰️ Terraform
* 🌲 AWS
* 📦 Docker
* 🏗️ Gradle / Maven
* 🏭 Jenkins
* 🕐 Git
* 🧪 JUnit and Mockito

---

Previously I worked at [TC](https://tc.com.br) doing:

Microservices in

* *🇬* Go

Using the following technologies:

* 🌱 Go Echo
* 🔍 ElasticSearch
* ☘️ MongoDB
* 📗 Google SQL and BigQuery
* 🪄 Goroutines and Channels
* ✉️ NATS
* 💾 Redis
* 📦 Docker
* 🏗️ Makefile
* 🏭 Jenkins
* 🕐 Git

---

And at [Meza](https://meza.digital/) as a Head of Technology with:

* *☕* Java
* *🇰* Kotlin

Using the following technologies:

* 🌱 Spring Boot
* 🔍 ElasticSearch
* 📗 Postgres
* 🪄 Reactive Stack and Coroutines
* 💾 Redis
* 📦 Docker
* 🏗️ Gradle
* 🏭 Jenkins and GitHub Actions
* 🕐 Git

*I was responsible for the major design decisions on customer projects, as well for improving and implementing 
Scalability, Reliability and Traceability in their projects, as well as significant performance improvements. I was able
to reduce their most important process from a total of 6 hours to just 30 minutes, with recovering capabilities and
parallel computing.*

---

And at [Looqbox](https://looqbox.com), here I was responsible for:

* 🛠️ Maintain
* 💻 Develop
* 📐 Architect 

Microservices in

* *☕* Java
* *🇰* Kotlin

Using the following technologies:

* 🌱 Spring Boot and Ktor
* 🔍 ElasticSearch
* ☘️ MongoDB
* 📗 MySQL and BigQuery
* 🪄 Reactive Stack and Coroutines
* 🔑 OAuth2, SAML and LDAP Auth
* 🕸️ Spring Boot Gateway (and Zuul)
* ✉️ RabbitMQ
* 💾 Redis
* 📡 Inter-Process Communication (IPC): Java, Python and R communication
* 📦 Docker
* 🏗️ Gradle
* 🏭 Jenkins
* 🕐 Git
* 🧪 JUnit and Mockito

*I've also worked with freelance projects using Delphi, Pawn, PHP and Java.*

#### Personal Projects **🧍** 

* [Bytecode Generation Tools](https://github.com/KoresFramework) [Kotlin]
* [Dependency Injection Framework](https://github.com/JonathanxD/Redin) [Kotlin]
* [CLI Parsing Library](https://github.com/JonathanxD/KWCommands) [Kotlin]
* [Configuration Library](https://github.com/JonathanxD/Config) [Java]
* [Unix Editor Helper Utility](https://github.com/JonathanxD/editor-server) [Rust]
* [Java Utility Library](https://github.com/JonathanxD/JwIUtils) [Java]

### 🌱 Programming Languages I know (ordered by years of continuously using and studying it)

I understand the important concepts behind different programming languages, from pure functional to multiparadigm ones. I'm very comfortable to work with any language, even those I've never touched.

Programming languages are just tools, you chose what best fits your needs, and you should never be afraid of using a different tool to get the work done.

* Java (10 years)
* Kotlin (8 years)
* Rust (6 years)
* Javascript, Lua (4 years)
* Scala, Groovy (3 years)
* Golang, Python (2 years)
* Kotlin/Native, Pawn, Golo, Gosu, Ceylon (1 year)
* PHP, Delphi, Visual Basic, C#, C/C++, Perl (< 1 year)
* Nim, Clojure, Haskell (some months to get interesting concepts)

### 🪛 Main Frameworks, Tools, Databases and SOs

#### Frameworks
* Spring
* Ktor
* Coroutines
* Micrometer
* RxJava1/2, Reactive Core
* JUnit, Mockito and Kotest
* ByteBuddy

#### Tools/Languages
* Java, Kotlin and Rust
* VisualVM/JConsole
* Docker
* Git, Pijul
* Gradle, Maven, Make
* Neovim
* IntelliJ IDEA
* JetBrains Space and TeamCity
* Grafana

#### Databases
* SQL: Postgresql, MySQL
* NoSQL: MongoDB, Redis, ElasticSearch
* NoSQL: InfluxDB, Cassandra, SurrealDB
* Hybrid: BigQuery

#### Operational Systems
* Linux (Debian-based, RPM-based, and independent ones)
* Windows
* Windows Server
* macOS
* FreeBSD

### 🧰 Frameworks and Concepts I know (apart from the ones that I use on my job)

* Java EE (now Jakarta EE)
* Dependency Injection (Guice, Koin)
* Collections (Google Guava and Fastutil)
* Serialization (Jackson/Gson/Kotlinx Serialization)
* Circuit Breaker (Resilience4J)
* Message Broker (Kafka and RabbitMQ)
* Event Driven Development ([EventSys](https://github.com/KoresFramework/EventSys))
* Concurrent, Async and Parallel Programming (Java 8 Streams, CompletableFuture, Thread Pool, Coroutines, Event Loop/Reactive Stack)
* Functional Programming (Java 8 Lambda, Scala, Kotlin and Haskell)
* Immutability (Immutable Data Structures)
* High Availability (Netflix Stack and Spring Cloud Stack)
* Serverless (Ktor and Spring)
* Sampling, Profiling and Monitoring (VisualVM, Micrometer, InfluxDB, Grafana and Prometheus)
* Deadlock Analysis using Thread Dump
* Memory Leak Analysis using VisualVM
* Performance improvement (find the problem, calculate the time complexity, architect a solution and apply the new algorithm with a better time complexity)
* Software Planning and Architecture

### 📫 How to reach me

* ✉️ Email: jhrldev@gmail.com
* 📇 Linkedin: https://www.linkedin.com/in/jhrldev

### 📱 Social Media

* Medium: https://jhrl.medium.com

### ⚡ Fun Fact

I started developing software in 2010, when I was only 10 years old and had no internet connection. First I learned Lua and was amazed
with what I did with it and what I could do, but it would be hard without access to the internet. So I started fixing the computers of my friends and neighbours to get some money, and with that I went to a lan house to research more about programming and download the software and documentation that I needed.

Interestingly, that was also how I did my first “job”, I used mobile GSM internet to communicate with my customer, and went to a Cybercafé to
send them the packages and test it out.

Being always curious led me to Linux in 2014, then to FreeBSD a couple of years after.

My love is not only for the code, but for the technology, so I keep learning anything that interests me in this field.
Which includes learning about Hardware Architecture, ISAs, Operating Systems (the underlying implementation), Reverse
Engineering (which is how I learned to create my own compiler), and so on.

The most challenging project was creating my own JVM compiler, which translates Concrete Trees into JVM Bytecode.
This was the most challenging project I ever worked in my life, I learned about Stack, Heap, Garbage Collection, JIT,
a bunch of JVM Internal things, such as Lookup Switch, Table Switch, Stack VM (and consequently, Register VMs).
One of the benefits of getting so much knowledge about the JVM (beyond the Java language), is knowing how to analyse
and optimise Java Applications, as I not only know what is an inefficient solution, but I also know what is inefficient
for the JVM.

This also motivated me to start writing my own Programming Language and learning more about Parsers and compilers,
especially the [LLVM](https://llvm.org/).
